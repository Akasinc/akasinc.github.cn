<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>my first blog</title>
    <link href="/2022/05/10/my-first-blog/"/>
    <url>/2022/05/10/my-first-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><img src="/2022/05/10/my-first-blog/LinkandMarlin.png" style="zoom: 20%"><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/10/hello-world/"/>
    <url>/2022/05/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>键盘电子乐器演奏程序设计</title>
    <link href="/2004/05/03/%E9%94%AE%E7%9B%98%E7%94%B5%E5%AD%90%E4%B9%90%E5%99%A8%E6%BC%94%E5%A5%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2004/05/03/%E9%94%AE%E7%9B%98%E7%94%B5%E5%AD%90%E4%B9%90%E5%99%A8%E6%BC%94%E5%A5%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="键盘电子乐器演奏程序设计"><a href="#键盘电子乐器演奏程序设计" class="headerlink" title="键盘电子乐器演奏程序设计"></a>键盘电子乐器演奏程序设计</h2><blockquote><p>学号：19030100438<br>姓名：周祖铨<br>班级：1903015</p></blockquote><h3 id="一、课程设计目的"><a href="#一、课程设计目的" class="headerlink" title="一、课程设计目的"></a>一、课程设计目的</h3><ol><li>了解利用 8254 定时器产生不同音符的原理及方法。</li><li>加深对计算机键盘扫描程序和执行过程的理解。</li><li>初步掌握键盘电子乐器演奏程序的设计方法。</li></ol><h3 id="二、课程设计的内容"><a href="#二、课程设计的内容" class="headerlink" title="二、课程设计的内容"></a>二、课程设计的内容</h3><ol><li>设计一个可以通过微机键盘演奏不同音乐的控制系统。</li><li>系统通过按下微机键盘模仿电子琴键驱动实验箱上的喇叭发生。</li><li>实现演奏音乐的功能，并在自动演奏时将键值返回到微机系统，实现按键反馈。</li></ol><h3 id="三、课程设计实验环境"><a href="#三、课程设计实验环境" class="headerlink" title="三、课程设计实验环境"></a>三、课程设计实验环境</h3><ol><li>硬件配置：<br>微机一台 （Pentium 4）<br>微机接口技术实验箱 一个<br>ISA – PCI 转接卡 一块<br>连接电缆 一条<br>万用表 一块<br>微机接口技术实验讲义 一本<br>连接导线</li><li>软件环境：<br>Windows XP&#x2F;2000&#x2F;Win 7 平台<br>Visual C++ 6.0 编译器</li></ol><h3 id="四、系统功能与设计要求"><a href="#四、系统功能与设计要求" class="headerlink" title="四、系统功能与设计要求"></a>四、系统功能与设计要求</h3><ol><li><p>基本功能要求<br>  能够演奏 C 调包含高、中、低音的不同节拍的乐曲，音调与频率的对应关系如下：<br>  中音：1 ~ 523Hz, 2 ~ 575Hz, 3 ~ 659Hz, 4 ~ 698Hz, 5 ~ 784Hz, 6 ~ 880Hz, 7 ~ 988Hz<br>  低 8 度音：基本音频率 &#x2F;2，例如低音 1 为 523&#x2F;2 &#x3D; 261.5Hz<br>  高 8 度音：基本音频率 x2，例如高音 1 为 523x2 &#x3D; 1046Hz。</p></li><li><p>发挥部分</p><ul><li>增加自动演奏乐曲功能。当按下 P 键后，自动播放一首乐曲，曲长大于 20 秒。</li><li>增加琴键图形显示功能。屏幕上显示21个琴键（高中低音），当按下某键后屏幕上的对应琴键有所反映。</li><li>增加一个音调 D，当从 C 调改为 D 调后，演奏音按照 D 调(比 C 高一个调)发音。</li></ul></li></ol><h3 id="五、设计思路"><a href="#五、设计思路" class="headerlink" title="五、设计思路"></a>五、设计思路</h3><ol><li>设计方案：<br>  一首乐曲由若干音符组成，一个音符对应一个频率，将与一个频率对应的计数初值写入计数器就可以产生相的频率，计算公式如下：计数初值 &#x3D; CLK0(输入频率)&#x2F;OUT0（输出频率）。<br>当音符对应的频率确定后，还需要知道每个音符演奏的时间。我们知道，音符的演奏时间是由节拍控制的，分为一拍，半拍，1&#x2F;4 拍，1&#x2F;8……，如果在一首乐曲中，音符演奏的最短时间是 1&#x2F;8 拍，我们就将 1&#x2F;8 拍作为一个最短时间单位 1，那么 1&#x2F;4 拍单位时间就是 2，1&#x2F;2 拍就是 4，一拍就是 8，假定一拍的时间为 1s，那么1&#x2F;2，&#x2F;1&#x2F;4，1&#x2F;8 拍的时间就是0.5s，0.25s，0.125s。<br>  音符的演奏时间 &#x3D; 单位时间 × N ( N 为调式参数，影响音乐的节奏)<br>  编程首先应该对计数器初始化，然后扫描键盘，根据扫描结果选择对应的频率，输出到实验箱的音频电路输入端口，并调用延时子程序控制节拍。</li><li>电路设计以及部分设计说明：<br><img src="/2004/05/03/%E9%94%AE%E7%9B%98%E7%94%B5%E5%AD%90%E4%B9%90%E5%99%A8%E6%BC%94%E5%A5%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/picture\电子琴电路图.png"><ul><li>片选端口选择CS2和CS4，则编程时初始化端口应该在对应范围内双向选择<br><img src="/2004/05/03/%E9%94%AE%E7%9B%98%E7%94%B5%E5%AD%90%E4%B9%90%E5%99%A8%E6%BC%94%E5%A5%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/cs24.png"></li><li>CLK0选择2MHz方波并不一定，只需要后面能分频出对应音符的频率。</li><li>8253芯片两个GATE端接VCC是为了在模式2和模式3下计数器持续计数。</li></ul></li><li>程序设计：</li></ol><ul><li><p>全局定义（按8253、8250示例程序定义）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">outportb</span><span class="hljs-params">( <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">char</span>)</span>;<span class="hljs-comment">//写I/O</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> <span class="hljs-title function_">inportb</span><span class="hljs-params">( <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> )</span>;        <span class="hljs-comment">//读I/O</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> u8  unsigned char <span class="hljs-comment">//定义无符号8位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> u16 unsigned int  <span class="hljs-comment">//定义无符号16位</span></span><br><br><span class="hljs-comment">//标注感叹号为本程序利用到的端口</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RHR0x240<span class="hljs-comment">//接收数据缓冲区!!</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THR0x240<span class="hljs-comment">//发送数据缓冲区</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IER0x241<span class="hljs-comment">//中断控制寄存器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FCR0x242<span class="hljs-comment">//FIFO控制寄存器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ISR0x242<span class="hljs-comment">//中断状态寄存器!!</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LCR0x243<span class="hljs-comment">//串行口控制寄存器!!</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MCR0x244<span class="hljs-comment">//MODEM控制寄存器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LSR0x245<span class="hljs-comment">//串行口状态寄存器!!</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSR0x246<span class="hljs-comment">//MODEM状态寄存器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DLL0x240<span class="hljs-comment">//波特率除数锁存器低位!!</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DLM0x241<span class="hljs-comment">//波特率除数锁存器高位!!</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COM_ADDR0x26f            </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T0_ADDR0x26c</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T1_ADDR0x26d    <span class="hljs-comment">//CS2口地址范围为0x0260H到0x026fH，双向选择中，A1、A0选择三个通道或者8253的控制字</span></span><br><span class="hljs-type">char</span> base = <span class="hljs-number">0x50</span>;<br><span class="hljs-type">char</span> low[<span class="hljs-number">21</span>]=&#123;<span class="hljs-number">0x53</span>,<span class="hljs-number">0x39</span>,<span class="hljs-number">0x21</span>,<span class="hljs-number">0x14</span>,<span class="hljs-number">0x02</span>,<span class="hljs-number">0x90</span>,<span class="hljs-number">0x81</span>,  <span class="hljs-number">0x76</span>,<span class="hljs-number">0x69</span>,<span class="hljs-number">0x61</span>,<span class="hljs-number">0x57</span>,<span class="hljs-number">0x51</span>,<span class="hljs-number">0x45</span>,<span class="hljs-number">0x40</span>,  <span class="hljs-number">0x38</span>,<span class="hljs-number">0x34</span>,<span class="hljs-number">0x30</span>,<span class="hljs-number">0x28</span>,<span class="hljs-number">0x25</span>,<span class="hljs-number">0x23</span>,<span class="hljs-number">0x20</span>&#125;;<span class="hljs-comment">//不同音符低八位</span><br><span class="hljs-type">char</span> high[<span class="hljs-number">21</span>]=&#123;<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x01</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,  <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,  <span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>,<span class="hljs-number">0x00</span>&#125;;<span class="hljs-comment">//不同音符高八位</span><br></code></pre></td></tr></table></figure></li><li><p>准确获取对应频率的音符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//实现原理：使8253通道0工作在模式2，通道1工作在模式1，分频、方波产生后的频率＝2MHz/(base*high+low),此处加号为低八位和高八位连接。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">setFrequency</span><span class="hljs-params">(<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> i)</span>&#123; <br>    outportb( COM_ADDR, <span class="hljs-number">0x35</span>);  <span class="hljs-comment">//设置通道0为方式2，计数器16位，BCD计数</span><br>    outportb( T0_ADDR, base); <br>    outportb( T0_ADDR, <span class="hljs-number">0</span>);    <span class="hljs-comment">//base = 0x50，clk50分频,得到40000hz</span><br>    outportb( COM_ADDR, <span class="hljs-number">0x77</span>);<span class="hljs-comment">//设置通道1为方式3，计数器16位，BCD计数</span><br>    outportb( T1_ADDR, low[j]); <br>    outportb( T1_ADDR, high[j]);<br>    delay(i);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>延迟函数实现节拍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//实现原理：实现方式为软件中断，即让CPU空转来实现延迟，参考的数值为：8086时钟频率为5MHz，每个总线周期需要4个时钟周期，下面程序循环部分划分为原子操作为4条语句。按照此设置下面参数，计算结果与实际结果有差别，最后解决方式是用手表测试蜂鸣器每两次响应之间是否大约为1s来调整参数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">delay</span><span class="hljs-params">(u16 p)</span><br>&#123;<br>u16 i;<br>p = p*<span class="hljs-number">500</span>;<br><span class="hljs-keyword">while</span>(p--)<br>&#123;<br>i = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">do</span><br>&#123;;&#125;<span class="hljs-keyword">while</span>(--i);<br>&#125;<br>&#125;<br><span class="hljs-comment">//更好的解决方案：用8259实现硬件中断，即当8253不需要工作时，暂停工作让出CPU，减少资源浪费</span><br></code></pre></td></tr></table></figure></li><li><p>保持待机状态原理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//处理办法是否简单粗暴，即直接设置8253通道0和1的计数器为0，则不产生方波，OUT1输出一直为1。存在BUG，由于8253减法计数器在设置为0时，并不会停止工作，当16位计数器从65535又减到0的时候（这段时间大概是2-3三分左右），会使蜂鸣器继续工作。解决办法：在后面while循环中再调用end函数。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">end</span><span class="hljs-params">()</span>&#123;<br>outportb( COM_ADDR, <span class="hljs-number">0x35</span>);<br>outportb( T0_ADDR, <span class="hljs-number">0</span>);<br>outportb( T0_ADDR, <span class="hljs-number">0</span>);<br>outportb( COM_ADDR, <span class="hljs-number">0x77</span>);<br>outportb( T1_ADDR, <span class="hljs-number">0</span>);<br>outportb( T1_ADDR, <span class="hljs-number">0</span>);<span class="hljs-comment">//输出高电平，使得蜂鸣器保持安静 </span><br>&#125;<br><span class="hljs-comment">//更好的办法：同上述延迟函数，用硬件中断</span><br></code></pre></td></tr></table></figure></li><li><p>自动播放音乐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//播放音乐，即将music数组编码依次输入与编码数组对比，依次输出相应频率的高低音，播放乐曲</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span>&#123;                <br>    <span class="hljs-type">int</span> i;<br>u8 ch;<br>u8 ch2 = <span class="hljs-number">0x55</span>;<br>u8 ch3 = <span class="hljs-number">0xAA</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">59</span>; i++) &#123;<br>setFrequency(music[i],music2[i]);<br>Send_Group(&amp;ch2,<span class="hljs-number">1</span>);<br>Send_Group(&amp;ch3,<span class="hljs-number">1</span>);<br>ch = music[i];<br>Send_Group(&amp;ch,<span class="hljs-number">1</span>);<br>&#125;<br>    <br>  Send_Group(&amp;ch2,<span class="hljs-number">1</span>);<br>Send_Group(&amp;ch3,<span class="hljs-number">1</span>);<br>ch = <span class="hljs-number">0</span>;<br>Send_Group(&amp;ch,<span class="hljs-number">1</span>);<br>end();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关于8250的一些理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化8250也就是初始化控制字，告诉8250之后的工作方式，随后传入的数据按照初始化的工作方式工作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init8250</span><span class="hljs-params">()</span><br>&#123;<br>outportb(ISR, <span class="hljs-number">0x6</span>);<span class="hljs-comment">//中断状态寄存器</span><br>outportb(LCR, <span class="hljs-number">0x83</span>);<span class="hljs-comment">//允许访问波特率因子寄存器</span><br>outportb(DLL, <span class="hljs-number">40</span>);<span class="hljs-comment">//波特率设为4800=(3.072*1000000/16)/DLMDLL</span><br>outportb(DLM, <span class="hljs-number">0x0</span>);<br>outportb(LCR, <span class="hljs-number">0x1b</span>);<span class="hljs-comment">//不允许访问波特率因子寄存器;数据格式为8数据位,1停止位,偶校验</span><br>&#125;<br><br><span class="hljs-comment">//接受一个字节</span><br>u8 <span class="hljs-title function_">Receive_Byte</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">while</span> ((inportb(LSR) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//读入状态</span><br>&#123;;&#125;<span class="hljs-comment">//有数据吗？</span><br><span class="hljs-keyword">return</span> inportb(RHR);<br>&#125;<br><br><span class="hljs-comment">//接受一组数据,count--接受数目</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Receive_Group</span><span class="hljs-params">(u8* pBuffer, <span class="hljs-type">int</span> count)</span><br>&#123;<br><span class="hljs-keyword">while</span>(count--)<br>*pBuffer++= Receive_Byte();<br>&#125;<br><br><span class="hljs-comment">//发送一个字节</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Sendbyte</span><span class="hljs-params">(u8 sdata)</span><br>&#123;<br>u8 i;<br><span class="hljs-type">int</span> j = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">while</span> ((inportb(LSR) &amp; <span class="hljs-number">0x20</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//读入状态</span><br>&#123;<br><span class="hljs-keyword">if</span> (j-- == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>outportb(RHR,sdata);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//发送一组数据, count--发送数目</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Send_Group</span><span class="hljs-params">(u8* pBuffer, <span class="hljs-type">int</span> count)</span><br>&#123;<br><span class="hljs-keyword">while</span> (count--)<br>&#123;<br><span class="hljs-keyword">if</span> (SendByte(*pBuffer++) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="六、心得体会"><a href="#六、心得体会" class="headerlink" title="六、心得体会"></a>六、心得体会</h3><p>本次实验第一天熟悉8250和8253的硬件特点，和上学期学的微机原理理论联系起来加深了对两个芯片的理解。在实验过程中遇到了很多关于底层的问题，比如上面提到的蜂鸣器会在待机状态又响起来，都是通过不断深入理解硬件特性来解释现象，并给出解决方案的。总的来说，本次实验获得了一次实际操作的机会，十分珍贵，最后电子琴弹出了自己喜欢的音乐，成就感满满。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
